import pandas as pd
   
   # Load the ratings data
ratings_df = pd.read_csv('ratingsappdata - Sheet1.csv')
   
   # Basic statistics
print("Total rows:", len(ratings_df))
print("Total users:", ratings_df['Name'].nunique())
print("Columns:", ratings_df.columns.tolist())
   
   # Check for user information
print("\nUser demographic columns:")
demographic_cols = ['Name', 'Email', 'Age', 'Gender', 'Height_cm', 
                       'Weight_kg', 'Dietary_tolerance_mg_per_day', 'Selected_Cuisines']
for col in demographic_cols:
    if col in ratings_df.columns:
        print(f"  ✓ {col}")



def extract_food_ratings(ratings_df):
       """
       Convert wide-format ratings to long-format (user, food, rating)
       """
       # Demographic columns to exclude
       demographic_cols = ['Name', 'Email', 'Age', 'Gender', 'Height_cm', 
                          'Weight_kg', 'PHE_tolerance', 'Dietary_tolerance_mg_per_day',
                          'Selected_Cuisines', 'Timestamp']
       
       # Food columns are those with food names (usually contain parentheses)
       food_columns = [col for col in ratings_df.columns 
                      if col not in demographic_cols and '(' in col]
       
       print(f"Found {len(food_columns)} food rating columns")
       
       # Convert to long format
       user_food_ratings = []
       
       for idx, row in ratings_df.iterrows():
           user_name = row['Name']
           user_email = row['Email']
           
           for food_col in food_columns:
               rating = row[food_col]
               
               # Skip if rating is missing or empty
               if pd.notna(rating) and rating != '':
                   try:
                       rating_value = float(rating)
                       user_food_ratings.append({
                           'user_name': user_name,
                           'user_email': user_email,
                           'food': food_col,
                           'rating': rating_value
                       })
                   except (ValueError, TypeError):
                       # Skip thumb up/down or invalid ratings
                       continue
       
       long_df = pd.DataFrame(user_food_ratings)
       return long_df
   
   # Execute extraction
user_food_df = extract_food_ratings(ratings_df)
print(f"\nTotal user-food rating pairs: {len(user_food_df)}")
print(f"Rating distribution:\n{user_food_df['rating'].value_counts().sort_index()}")



# Ratings per user
ratings_per_user = user_food_df.groupby('user_name').size()
print(f"\nRatings per user:")
print(f"  Mean: {ratings_per_user.mean():.1f}")
print(f"  Median: {ratings_per_user.median():.1f}")
print(f"  Min: {ratings_per_user.min()}")
print(f"  Max: {ratings_per_user.max()}")
    
    # Ratings per food
ratings_per_food = user_food_df.groupby('food').size()
print(f"\nRatings per food:")
print(f"  Mean: {ratings_per_food.mean():.1f}")
print(f"  Median: {ratings_per_food.median():.1f}")
print(f"  Foods rated by only 1 user: {(ratings_per_food == 1).sum()}")
print(f"  Foods rated by 3+ users: {(ratings_per_food >= 3).sum()}")



def extract_user_profiles(ratings_df):
       """
       Extract user demographic and dietary information
       """
       user_profiles = []
       
       for idx, row in ratings_df.iterrows():
           profile = {
               'user_name': row['Name'],
               'user_email': row['Email'],
               'age': row.get('Age', None),
               'gender': row.get('Gender', None),
               'height_cm': row.get('Height_cm', None),
               'weight_kg': row.get('Weight_kg', None),
               'phe_tolerance_mg_per_day': row.get('Dietary_tolerance_mg_per_day', 
                                                    row.get('PHE_tolerance', None)),
               'selected_cuisines': row.get('Selected_Cuisines', '')
           }
           user_profiles.append(profile)
       
       return pd.DataFrame(user_profiles)
   
user_profiles_df = extract_user_profiles(ratings_df)
print("\nUser profiles extracted:")
print(user_profiles_df.head())
   
   # Check for missing values
print("\nMissing values in user profiles:")
print(user_profiles_df.isnull().sum())


def calculate_user_nutritional_limits(user_profile):
       """
       Calculate personalized nutritional limits based on user profile
       Uses the same logic as your finalapp.py
       
       Returns: dict with phe_mg_min, phe_mg_max, protein_g, energy_kcal
       """
       age = user_profile['age']
       weight_kg = user_profile['weight_kg']
       gender = user_profile['gender']
       
       if pd.isna(age) or pd.isna(weight_kg):
           return None
       
       age_months = age * 12  # Convert to months
       
       # Infant (0-12 months)
       if age_months < 12:
           return get_infant_daily_needs(age_months, weight_kg)
       # Child/Adult
       else:
           return get_child_adult_daily_needs(age_months, weight_kg, gender)
   
def get_infant_daily_needs(age_months, weight_kg):
       """Copy from your finalapp.py"""
       needs = {}
       if age_months < 3:
           needs.update({
               'protein_g_per_kg': 3.5, 
               'phe_mg_per_kg_min': 25, 
               'phe_mg_per_kg_max': 70, 
               'energy_kcal_per_kg': 120,
               'age_group': '0-3 months'
           })
       elif age_months < 6:
           needs.update({
               'protein_g_per_kg': 3.5,
               'phe_mg_per_kg_min': 20,
               'phe_mg_per_kg_max': 45,
               'energy_kcal_per_kg': 120,
               'age_group': '3-6 months'
           })
       elif age_months < 9:
           needs.update({
               'protein_g_per_kg': 3.0,
               'phe_mg_per_kg_min': 15,
               'phe_mg_per_kg_max': 35,
               'energy_kcal_per_kg': 110,
               'age_group': '6-9 months'
           })
       else:
           needs.update({
               'protein_g_per_kg': 3.0,
               'phe_mg_per_kg_min': 10,
               'phe_mg_per_kg_max': 35,
               'energy_kcal_per_kg': 105,
               'age_group': '9-12 months'
           })
       
       needs['protein_g'] = needs['protein_g_per_kg'] * weight_kg
       needs['phe_mg_min'] = needs['phe_mg_per_kg_min'] * weight_kg
       needs['phe_mg_max'] = needs['phe_mg_per_kg_max'] * weight_kg
       needs['energy_kcal'] = needs['energy_kcal_per_kg'] * weight_kg
       
       return needs
   
def get_child_adult_daily_needs(age_months, weight_kg, sex):
       """Copy from your finalapp.py"""
       needs = {}
       if age_months < 48:
           needs.update({
               'phe_mg_min': 200, 
               'phe_mg_max': 400, 
               'protein_g': 30, 
               'energy_kcal': 1300,
               'age_group': '1-4 years'
           })
       elif age_months < 84:
           needs.update({
               'phe_mg_min': 210,
               'phe_mg_max': 450,
               'protein_g': 35,
               'energy_kcal': 1700,
               'age_group': '4-7 years'
           })
       elif age_months < 132:
           needs.update({
               'phe_mg_min': 220,
               'phe_mg_max': 500,
               'protein_g': 40,
               'energy_kcal': 2400,
               'age_group': '7-11 years'
           })
       elif age_months < 180:
           if sex == "Female":
               needs.update({
                   'phe_mg_min': 250,
                   'phe_mg_max': 750,
                   'protein_g': 50,
                   'energy_kcal': 2200,
                   'age_group': '11-15 years'
               })
           else:
               needs.update({
                   'phe_mg_min': 225,
                   'phe_mg_max': 900,
                   'protein_g': 55,
                   'energy_kcal': 2700,
                   'age_group': '11-15 years'
               })
       elif age_months < 228:
           if sex == "Female":
               needs.update({
                   'phe_mg_min': 230,
                   'phe_mg_max': 700,
                   'protein_g': 55,
                   'energy_kcal': 2100,
                   'age_group': '15-19 years'
               })
           else:
               needs.update({
                   'phe_mg_min': 295,
                   'phe_mg_max': 1100,
                   'protein_g': 65,
                   'energy_kcal': 2800,
                   'age_group': '15-19 years'
               })
       else:
           if sex == "Female":
               needs.update({
                   'phe_mg_min': 220,
                   'phe_mg_max': 700,
                   'protein_g': 60,
                   'energy_kcal': 2100,
                   'age_group': '19+ years'
               })
           else:
               needs.update({
                   'phe_mg_min': 290,
                   'phe_mg_max': 1200,
                   'protein_g': 70,
                   'energy_kcal': 2900,
                   'age_group': '19+ years'
               })
       
       return needs

# Calculate limits for each user
user_limits_list = []
   
for idx, user_profile in user_profiles_df.iterrows():
       limits = calculate_user_nutritional_limits(user_profile)
       
       if limits is not None:
           limits['user_name'] = user_profile['user_name']
           limits['user_email'] = user_profile['user_email']
           user_limits_list.append(limits)
   
user_limits_df = pd.DataFrame(user_limits_list)
   
print("User nutritional limits calculated:")
print(user_limits_df[['user_name', 'age_group', 'phe_mg_min', 
                          'phe_mg_max', 'protein_g', 'energy_kcal']].head())
   
   # Save for later use
user_limits_df.to_csv('user_nutritional_limits.csv', index=False)

def load_all_food_databases():
       """
       Load all food databases (consolidated + cuisine-specific)
       """
       # Load consolidated database
       consolidated_foods = {}
       try:
           df = pd.read_csv("consolidated_chat_ingredients.csv")
           df.columns = [c.strip().lower() for c in df.columns]
           
           if "ingredient" in df.columns:
               df = df.rename(columns={"ingredient": "name"})
           
           for c in ["phe(mg)", "protein(g)", "energy(kcal)", "serving_size(g)"]:
               if c in df.columns:
                   df[c] = pd.to_numeric(df[c], errors="coerce").fillna(0.0)
           
           if "name" in df.columns:
               df["name"] = df["name"].astype(str).str.strip().str.lower()
               
               for _, row in df.iterrows():
                   consolidated_foods[row['name']] = {
                       'phe_mg_per_100g': row['phe(mg)'],
                       'protein_g_per_100g': row['protein(g)'],
                       'energy_kcal_per_100g': row['energy(kcal)'],
                       'serving_size_g': row.get('serving_size(g)', 100.0)
                   }
       except FileNotFoundError:
           print("Consolidated foods CSV not found")
       
       print(f"Loaded {len(consolidated_foods)} foods from consolidated database")
       return consolidated_foods
   
food_db = load_all_food_databases()


def get_food_nutrients(food_name, food_db):
       """
       Get nutritional information for a food
       Returns nutrients per 100g
       """
       # Clean food name (remove cuisine tag if present)
       clean_name = food_name.lower().strip()
       if '(' in clean_name:
           # Extract just the food name before cuisine tag
           clean_name = clean_name.split('(')[0].strip()
       
       # Try to find in database
       if clean_name in food_db:
           return food_db[clean_name]
       
       # Try fuzzy matching
       for db_food in food_db:
           if clean_name in db_food or db_food in clean_name:
               return food_db[db_food]
       
       # Not found - will need to use USDA API or estimate
       return None
   
   # Check coverage of rated foods
unique_foods = user_food_df['food'].unique()
print(f"\nTotal unique foods rated: {len(unique_foods)}")
   
foods_found = 0
foods_missing = []
   
for food in unique_foods:
       nutrients = get_food_nutrients(food, food_db)
       if nutrients is not None:
           foods_found += 1
       else:
           foods_missing.append(food)
   
print(f"Foods found in database: {foods_found} ({foods_found/len(unique_foods)*100:.1f}%)")
print(f"Foods missing: {len(foods_missing)}")
   
if foods_missing:
       print("\nSample of missing foods:")
       for food in foods_missing[:10]:
           print(f"  - {food}")

def fetch_missing_food_nutrients(food_name, usda_api_key):
       """
       Fetch nutrients from USDA for missing foods
       """
       # Use your existing search_usda_foods and get_usda_food_details functions
       results = search_usda_foods(food_name, usda_api_key)
       
       if results:
           details = get_usda_food_details(results[0]['fdcId'], usda_api_key)
           if details is not None:
               return {
                   'phe_mg_per_100g': details['phe(mg)'],
                   'protein_g_per_100g': details['protein(g)'],
                   'energy_kcal_per_100g': details['energy(kcal)'],
                   'serving_size_g': details.get('serving_size(g)', 100.0),
                   'source': 'USDA'
               }
       
       return None
   
   # Optional: Fetch missing foods from USDA
   # This requires your USDA API key
if False:  # Set to True if you want to fetch
       USDA_API_KEY = "your_key_here"
       
       for food in foods_missing:
           nutrients = fetch_missing_food_nutrients(food, USDA_API_KEY)
           if nutrients:
               food_db[food.lower()] = nutrients
               print(f"✓ Fetched: {food}")


